\documentclass[12pt]{article}

\usepackage[sfdefault]{ClearSans}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{color}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{eurosym}
\usepackage{graphicx}

\pagestyle{plain}
\title{Micro-projet}
\author{Hubert \bsc{Hirtz} \and Camille \bsc{Schnell}}
\date{22 octobre 2018}
\begin{document}
\maketitle
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage
\section{Introduction}
  L'objectif de ce micro-projet est d'implémenter un système d'e-shopping. Afin de faire cela, nous gérons des utilisateurs, ainsi que des articles, en base de données. Nous avons pour cela défini l'architecture du projet, en utilisant des design patterns répondant aux problèmes posés. \\
  Nous allons dans un premier présenter nos choix architecturaux, et indiquer quels designs patterns nous avons mis en place. Nous expliquerons ensuite la solution globale du projet, ainsi que la gestion des données. Nous fournirons enfin un manuel utilisateur de notre application, et nous finirons par les difficultés que nous avons pu rencontrer lors du déroulement du micro-projet.
\newpage
\section{Architecture et design patterns}

Le projet a été construit en gardant à l'esprit la séparation des préoccupations, afin de garder un code modulaire.
Ainsi, le code est séparé sous les quatres modules décrits dans la section suivante.

Une version dérivée du pattern \textit{Singleton} est utilisée dans \textbf{BeanManager} pour initialiser les deux beans chez les clients, et les réutiliser. Comme décrit sur le schéma ci-dessous, les instances \textit{DirectoryManager} et \textit{OrderManager} sont donc créées une seule fois, puis utilisées par les clients \textit{AdministrationClient} et \textit{OrderClient}.

\begin{center}
\includegraphics{singleton.png}
\end{center}

\newpage
Nous avons également utilisé le design pattern Model-View-Controller dans ce projet. En effet, nos classes \textbf{EUser}, \textbf{Article} et \textbf{Order} correspondent aux modèles ; les contrôleurs sont alors les beans, et les clients gèrent la partie interactive avec l'utilisateur et représentent ainsi nos vues.

\begin{center}
\includegraphics{mvc.png}
\end{center}

\newpage
\section{Solution et gestion des données}

La solution est composée de quatre modules :
\\ \\
\textbf{ejb-eshopping-api}

Le module contient les interfaces utilisées pour communiquer avec les beans, et ainsi modifier la base de données.
L'API est divisée en deux interfaces. Le \textbf{DirectoryManager} s'occupe des articles et des clients, tandis que l'\textbf{OrderManager} s'occupe des commandes. \\ \\
\textbf{ejb-eshopping-bean}

Le module contient les implémentations de ces interfaces. Vous trouverez ici le code qui accède à la base de données avec la JPA. \\ 
Le bean \textbf{DirectoryManagerBean} permet d'insérer, de trouver, de mettre à jour et de supprimer les utilisateurs et les articles. Il contient également une fonction permettant de récupérer tous les articles, que nous avons utilisés pour les afficher en console, et une fonction permettant de savoir si un artice est disponible ou non.\\
Le bean \textbf{OrderManagerBean} permet principalement de passer une commande à partir d'un utilisateur et de l'article qu'il souhaite commander.\\ \\
\textbf{ejb-eshopping-entity}

Le module contient les modèles de données avec les classes \textbf{Article}, \textbf{EUser} et \textbf{OrderT}.
Les schémas des tables sont :
\begin{itemize}
  \item Article(\underline{id}, description, categorie, nbDisponible)
  \item EUser(\underline{pseudo}, password, firstName, lastName, addresse, email, isAdminFlag)
  \item Order(\underline{id}, article, eUser, buyedAt)
\end{itemize}

\\ \\
\textbf{ejb-eshopping-client}

Le module contient le code qui accède aux beans, à savoir l'interface utilisateur et les scénarios.

Comme indiqué dans le sujet, les classe \textit{AdministrationClient} et \textit{OrderClient} gèrent respectivement les modifications d'articles/utilisateurs et la commande d'articles par les utilisateurs. La classe \textit{MainClient} utilise ces deux dernières afin de proposer une interaction à l'utilisateur (application console). La classe \textit{UtilsIHM} contient des fonctions d'affichage ou autres fonctionnalités nécessaires à plusieurs reprises dans différentes classes.

Afin d'authentifier les utilisateurs, chaque utilisateur a un pseudo unique et un mot de passe, ces derniers lui sont demandés avant chaque commande d'article. Un utilisateur peut afficher les articles de la base de données sans être authentifié. Si l'utilisateur est un administrateur, il a en plus le droit d'ajouter et de supprimer d'autres utilisateurs ou articles. Nous avons pour cela défini le flag \textit{isAdminFlag} dans la table \textbf{EUser}.

Dans le client \textit{AdministrationClient}, nous avons utilisé le mécanisme Future afin de simuler un réaprovisionnement des stocks en cas d'indisponibilité pour un article. Pour cela, la fonction \textit{newDelivery(int input)} renvoie le nouveau nombre d'articles en stock après un lapse de temps. La communication asynchrone entre le client et le serveur se fait donc grâce à ce mécanisme : une fois la fonction \textit{newDelivery} achevée, le client reçoit un message lui indiquant le nouveau nombre d'articles disponibles en utilisant la valeur de \textit{future.get()}.


\end{itemize}

\newpage
\section{Manuel d'utilisation}
    \subsection{Lancement du script de démonstration}
    Une interface est mise à disposition pour ajouter et supprimer des utilisateurs, des articles.
    Elle permet aussi de commander un article sous le nom d'un utilisateur, et d'afficher tous les articles.

    Pour lancer l'interface, il faut compiler le projet avec

    \texttt{mvn clean install}

    Puis lancer le domaine et la base de données glassfish. L'interface se lance ensuite avec

    \texttt{./interface.sh}

    Vous pouvez ensuite suivre les instructions affichées dans la console. Un utilisateur avec les droits d'administration est déjà présent dans la base de données (pseudo : admin, pass : admin).

    \subsection{Scénario client prédéfini}
    En plus de l'interface présentée ci-dessus, un scénario est mis à disposition. Pour l'exécuter, il suffit d'entrer la commande suivante :

    \texttt{./scenario.sh}

    Ce scénario permet de tester des méthodes des beans de l'application : nous créons d'abord deux utilisateurs et deux articles. L'un des utilisateurs commande un article. Enfin, nous supprimons le deuxième article.

\newpage
\section{Difficultés rencontrées}

La première difficulté à été de mettre en place l'environnement de développement.
La configuration est en effet longue et pénible pour un projet de cette ampleur-là.
Bien sûr, dans de grands projets d'entreprise, cette configuration prend tout son sens, en ce qu'elle permet de faire marcher de nombreux composants travaillant ensemble.

La seconde a été la modularité du projet.
Cela peut paraître surprenant, sachant que c'est un point qui a été abordé positivement dans la description de l'architecture, mais cette modularité nous a ralenti dans le développement.
Ce projet étant un projet d'apprentissage, nous l'avons abordé sans faire de spécification (p. ex. comme en cycle en V).
Les interfaces des modules évoluaient donc sans cesse, le développement en a été ainsi ralenti.

D'autres problèmes mineurs ont été rencontrés, comme l'annotation \texttt{@GeneratedValue} que nous n'avons pas réussi à faire fonctionner, mais nous avons réussi à passer outre ces difficultés en coutournant les problèmes ou en trouvant des solutions après recherches.

\end{document}
